{{ if eq .Values.benchmark "hot" -}}
{{ $numRows := mul .Values.scalefactor 1000 -}}
{{ $numRegions := sub (len .Values.ordered_namespaces) 1 -}}
{{ $numRowsPerRegion := 0 }}
{{ if not (empty $numRegions) }}
{{ $numRowsPerRegion = int (ceil (divf $numRows $numRegions)) -}}
{{ end }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: benchbase-config
  labels:
    app: benchbase-config
    benchmark: hot
    part-of: benchbase
data:
  config.xml: |
    <?xml version="1.0"?>
    <parameters>

        <!-- Connection details -->
        <type>POSTGRES</type>
        <driver>org.postgresql.Driver</driver>
        <url>jdbc:postgresql://compute:55433/postgres?sslmode=disable&amp;ApplicationName=ycsb&amp;reWriteBatchedInserts=true</url>
        <username>cloud_admin</username>
        <password></password>
        <isolation>TRANSACTION_SERIALIZABLE</isolation>
        <batchsize>128</batchsize>

        <ddlpath>/config/ddl.sql</ddlpath>

        <!-- Scalefactor in YCSB is *1000 the number of rows in the USERTABLE-->
        <scalefactor>{{ .Values.scalefactor }}</scalefactor>
        
        <!-- Optional: Override the field size for each column in USERTABLE -->
        <fieldSize>8</fieldSize>

        {{ if .Values.parallel_load -}}
        {{- $from := mul (sub .Values.namespace_id 1) $numRowsPerRegion }}
        {{- $to := min (add $from $numRowsPerRegion) $numRows }}
        <loadfrom>{{ $from }}</loadfrom>
        <loadto>{{ $to }}</loadto>
        {{- end }}

        <!-- Number of regions, excluding the global region -->
        <numregions>{{ $numRegions }}</numregions>
        <!-- Current region -->
        <region>{{ .Values.namespace_id }}</region>
        <!-- Number of hot keys per partition -->
        <hot>{{ .Values.hot.hot }}</hot>
        <!-- Number of keys per transaction -->
        <keyspertxn>{{ .Values.hot.keyspertxn }}</keyspertxn>

        <!-- The workload -->
        <terminals>{{ .Values.terminals }}</terminals>
        <works>
            <work>
                <time>{{ .Values.time }}</time>
                <rate>{{ .Values.rate }}</rate>
                <weights>{{ .Values.hot.weights }}</weights>
            </work>
        </works>

        <!-- HOT Procedures declaration -->
        <transactiontypes>
            <transactiontype>
                <name>ReadModifyWrite1</name>
            </transactiontype>
            <transactiontype>
                <name>ReadModifyWrite2</name>
            </transactiontype>
            <transactiontype>
                <name>ReadModifyWrite3</name>
            </transactiontype>
            <transactiontype>
                <name>ReadModifyWrite4</name>
            </transactiontype>
        </transactiontypes>
    </parameters>

  ddl.sql: |
    CREATE EXTENSION IF NOT EXISTS remotexact;
    DROP TABLE IF EXISTS usertable;
    CREATE TABLE usertable (
        ycsb_key int PRIMARY KEY,
        field1   text,
        field2   text,
        field3   text,
        field4   text,
        field5   text,
        field6   text,
        field7   text,
        field8   text,
        field9   text,
        field10  text
    ) PARTITION BY RANGE (ycsb_key);

    {{- if not (empty $numRegions) }}
    {{- range $i := until (int (sub $numRegions 1)) }}
    {{- $from := mul $i $numRowsPerRegion }}
    {{- $to := min (add $from $numRowsPerRegion) $numRows }}
    CREATE TABLE usertable_{{ add1 $i }} PARTITION OF usertable FOR VALUES FROM ({{ $from }}) TO ({{ $to }});
    {{- end }}
    {{- $from := (mul (sub (int $numRegions) 1) $numRowsPerRegion) }}
    CREATE TABLE usertable_{{ $numRegions }} PARTITION OF usertable FOR VALUES FROM ({{ $from }}) TO ({{ $numRows }});
    {{- end }}

    {{- range $i := until (int $numRegions) }}
    UPDATE pg_class SET relregion = {{ add1 $i }} WHERE relname = 'usertable_{{ add1 $i }}';
    UPDATE pg_class SET relregion = {{ add1 $i }} WHERE relname = 'usertable_{{ add1 $i }}_pkey';
    {{- end }}
{{ end }}